# action.yml
name: 'Changelog Generator'
description: 'Generates changelog on a pull request automatically'
inputs:
  token:
    description: 'GITHUB_TOKEN or a `repo` scoped Personal Access Token (PAT)'
    required: false
    default: ${{ github.token }}

  outputFile:
    description: 'The output file. Use output if not provided'
    required: false

  since:
    description: 'Tag to generate since. Uses since latest release if not provided'
    required: false

  sinceLatestRelease:
    description: 'Can use this in place of since to get change log since the latest release'
    required: false

  complete:
    description: 'Whether to generate the complete changelog. This is not recommended as it will fetch all tags and all pull requests. Complete and since cannot be used together.'
    required: false
    default: 'false'

  nextTag:
    description: 'The tag of the next version'
    required: false

  filter:
    description: 'Filter regex. Matching PR titles will be ignored.'
    required: false

  labels:
    description: 'Labels to group by'
    required: false

  excludedLabels:
    description: 'The labels to exclude from the change log'
    required: false

  branch:
    description: 'The branch to get change log for'
    required: false

  includeUntagged:
    description: 'Whether to include untagged PRs. Defaults to true.'
    required: true
    default: 'true'

  verbose:
    description: 'Enable verbose logging'
    required: false

  use-compiled:
    description: 'Whether to use compiled executable or not'
    required: false
    default: 'true'

outputs:
  changelog:
    description: the generated changelog
    value: ${{ steps.set-output.outputs.changelog }}

runs:
  using: "composite"
  steps:
    - name: Generate
      id: generate
      run: |
        repository="${{ github.repository }}"
        token="${{ inputs.token }}"
        outputFile="${{ inputs.outputFile }}"
        since="${{ inputs.since }}"
        complete="${{ inputs.complete }}"
        nextTag="${{ inputs.nextTag }}"
        filter="${{ inputs.filter }}"
        labels="${{ inputs.labels }}"
        includeUntagged="${{ inputs.includeUntagged }}"
        sinceLatestRelease="${{ inputs.sinceLatestRelease }}"
        verbose="${{ inputs.verbose }}"
        branch="${{ inputs.branch }}"
        excludedLabels="${{ inputs.excludedLabels }}"
        useCompiled="${{ inputs.use-compiled }}"

        MAC_OS_VERSION=$([[ "$OSTYPE" == "darwin"* ]] && sw_vers -productVersion)
        major="$(echo $MAC_OS_VERSION | awk 'BEGIN { FS="." } { print $1 }')"
        # For macOS 11 or lower while async/await works, it doesn't seem to work using the precompiled binary
        can_run_compiled_binary="$(if [[ $major -lt 12 ]]; then echo 'false'; else echo 'true'; fi)"

        # We use array because that's the only clean way to construct a command while preserving spaces
        # https://unix.stackexchange.com/questions/444946/how-can-we-run-a-command-stored-in-a-variable

        command=()
        if [[ "$OSTYPE" == "darwin"* && "$useCompiled" == "true" && "$can_run_compiled_binary" == "true" ]]; then
          # macos. Use pre-built binary
          command+=("${{ github.action_path }}/changelog")
        else
          # linux. Build the binary and run
          command+=("swift")
          command+=("run")
          command+=("--package-path=${{ github.action_path }}")
          command+=("changelog")
        fi

        command+=("generate")

        if [ -z "$repository" ]; then
          echo "Repository cannot be empty"
          exit 1
        else
          command+=("--repository=$repository")
        fi

        if [ -z "$token" ]; then
          echo "token is empty"
        else
          command+=("--token=$token")
        fi

        if [ "$complete" == "true" ]; then
          command+=("--type=complete")
        elif [ "sinceLatestRelease" == "true" ]; then
          command+=("--type=since-latest-release")
        elif [ -z "$since" ]; then
            echo "since is empty"
        else
            command+=("--type=sinceTag")
            command+=("--tag=$since")
        fi

        if [ -z "$nextTag" ]; then
          echo "nextTag is empty"
        else
          command+=("--next-tag=$nextTag")
        fi

        if [ -z "$outputFile" ]; then
          echo "outputFile is empty"
        else
          command+=("--output=$outputFile")
        fi

        if [ -z "$filter" ]; then
          echo "filter is empty"
        else
          command+=("--filter-reg-ex=$filter")
        fi

        if [ -z "$labels" ]; then
          echo "labels is empty"
        else
          command+=("--labels=$labels")
        fi

        if [ -z "$excludedLabels" ]; then
          echo "excludedLabels is empty"
        else
          command+=("--excluded-labels=$excludedLabels")
        fi

        if [ -z "$branch" ]; then
          echo "branch is empty"
        else
          command+=("--branch=$branch")
        fi

        if [ "$includeUntagged" == "false" ]; then
          command+=("--exclude-untagged")
        fi

        if [ "$verbose" == "true" ]; then
          command+=("--verbose")
        fi

        command+=("--log-console")

        changelog=${command[@]}

        # Add output to environment

        echo 'CHANGELOG_GENERATED_VALUE<<EOF' >> $GITHUB_ENV
        echo "$changelog" >> $GITHUB_ENV
        echo 'EOF' >> $GITHUB_ENV

      shell: bash

    - name: Set output
      id: set-output
      uses: actions/github-script@v6
      with:
        script: |
          const { CHANGELOG_GENERATED_VALUE } = process.env

          core.setOutput('changelog', CHANGELOG_GENERATED_VALUE)
